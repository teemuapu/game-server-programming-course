# Just enough REST

Note:

- Following will explain what a service following the REST architectural style should look like to a caller
- REST is effectively a restating or clarification of what an ideal web-based application should look like
- For making programming interfaces
- Meant to improve: performance, scalability, simplicity, ability to transform, movability and trustworthiness

---

## How does a RESTful API look like?

Typical URIs:

- GET /api/players/
- GET /api/players/{id} 
- POST /api/players/
- PUT /api/players/{id}
- DELETE /api/players/{id}
- GET /api/players/{id}/items/

https://dev.twitter.com/rest/public

Note:

- Typical methods are named with custom verbs, REST uses HTTP verbs
- Technically speaking, the REST architectural style is agnostic about any specific protocol. That includes the HTTPprotocol. - In other words, all you need is a protocol that provides a language and mechanism for describing both states(i.e., representations) and state changes. 

---

## REST

REST is an acronym for REpresentational State Transfer

REST is based solely on existing HTTP standards

Extremely interoperable across all platforms capable of making HTTP requests

Note:

- This not only includes computers, smartphones, and tablets, but it also gets into devices such as phone systems, ATM machines, refrigerators, alarm systems, browsers, smart watches, etc. As long as the device can make an HTTP request to a URL, it can “do” REST.

---

## REST architectural constraints

The REST architectural style describes six constraints:

- Client-Server architecture
- Uniform interface
- Stateless
- Cacheable
- Layered System
- Code on Demand (optional)

---

### REST: Uniform interface

Resources are in the center of the API

Individual resources are identified in requests

- URIs in Web-based REST systems: (…/api/players)

---

### REST: Uniform interface

Resources themselves are conceptually separate from the representations that are returned to  the client

- Server may return data from database in XML or JSON format which is not the same as the internal representation

When a client holds a representation of a resource, it has enough information to modify or delete the resource

---

### REST: Stateless

Server doesn’t store any client context

Each request from any client contains all the information necessary to service the request

The session state can be transferred by the server to another service such as a database to maintain a persistent state

HTTP is itself a stateless protocol

---

### REST: Layered System

A client cannot ordinarily tell whether it is connected directly to the end server, or to an intermediary along the way

Intermediary servers may improve system scalability by enabling load balancing and by providing shared caches

Intermediary servers may also enforce security policies

---

### HTTP verbs (HTTP methods)

HTTP verbs are used to act on or fetch information about resources

RESTful applications should choose the verbs to use from the verbs available in the protocol

- Typically all clients support GET and POST
- Most also support PUT and DELETE
- There are a few more less supported verbs: PATCH, HEAD, and OPTIONS

Not all verbs need to be supported for each resource type

Note:

- The use of the Delete verb is also hotly debated. Most enterprise applications don’t allow the caller to really delete a resource which would cause the verb to go unused if used only for deletes
- The debate over how the HTTP verbs are supposed to be used can be quite heated at times
- The important thing is to conform as closely to HTTP standards as possible

---

### HTTP verbs: Expected actions

|        | (Collection URI) http://myserver.com/players                                | (Element URI) http://myserver.com/players/1234                   |
| ------ | --------------------------------------------------------------------------- | ---------------------------------------------------------------- |
| GET    | List of players, including URIs to individual players                       | Get a specific player, identified by the URI                     |
| PUT    | Replace the entire collection of players                                    | Replace or create the single players identified  by the URI      |
| POST   | Create a new single player, where its identifier is generated by the system | Create a new subordinate under the player  identified by the URI |
| DELETE | Delete the entire collection of players                                     | Delete the players identified by the URI                         |

Note:

- The exact meaning of each of the four verbs is dependent on the URI (context)
- Even though there are 4 verbs you can use, there are actually 8 different actions available

---

### HTTP verbs: Idempotence

The GET, PUT, and DELETE methods are said to be idempotent

- calling them over and over will produce the same result without any additional side effects.

GET method should not change the system at all

DELETE method should delete the resource if it exist and not give any errors if it does not

---

### HTTP verbs: Idempotence

PUT method should update the resource if it already exists. Or, if it doesn’t exist, the system should create the resource as submitted. 

POST method is not idempotent, it should always result in a new resource instance for each call

---

### Errors

Only the well-known set of HTTP status codes should be used

API should give an useful error message for the developer

- Should be in same format as any other resource received from the API
- A good practice is to also include a more detailed description of the error in addition to the error message

Note:

When the application is in production, the error messages should not be so descriptive that they could reveal potential security holes

---

### HTTP status codes – some well known examples

200 - All is good

301 - The resource was moved

400 - Bad request

401 - Unauthorized

404 - Resource not found

409 - Conflict

500 - Server error

Note:

- You should definitely use at least these
- If starts with 2 – Everything is alright
- If starts with 3 – No errors but special action might need to be taken
- If starts with 4 – User has a problem
- If starts with 5 – Server has a problem

---

### Response format

Responses are usually made in JSON or XML

---

### JSON

JSON’s popularity is growin

Less verbose (quicker to read and write)

Very easy to use with JavaScript

---

### XML

More extension possibilities (not so relevant to  web APIs)

---

### Result filtering, sorting & searching

Filtering

- Use a unique query parameter for each field that implements filtering
- Example: GET /items?min_price=3

Sorting

- A generic parameter sort can be used to describe sorting rules
- Example: GET /items?sort=-price

---


### Result filtering, sorting & searching

Searching

- Combine filters, sorts and even full text search
- GET /tickets?q=return&state=open&sort=-priority,created_at

To make the API more pleasant, commonly used conditions can be packaged into easily accessible RESTful paths

- GET /tickets/recently_closed

---

### Overriding the HTTP method

Some HTTP clients can only work with simple GET and POST requests (Unity’s Www-class)

A popular convention is to accept a request header X-HTTP-Method-Override with a string value containing one of PUT, PATCH or DELETE

Note that the override header should only be accepted on POST requests
